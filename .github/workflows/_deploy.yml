name: Reusable Backend Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: "Logical environment to deploy to"
        required: true
        type: string
      deploy_target:
        description: "Deploy target: render | aws-ecs | gcp-cloudrun"
        required: true
        type: string
      image_tag:
        description: "Docker image tag or full image reference to deploy"
        required: true
        type: string
      service_url:
        description: "Base URL of the deployed service for health checks (e.g. https://api.staging.example.com)"
        required: false
        type: string
        default: ""
    secrets:
      DATABASE_URL:
        description: "Database connection URL for Prisma migrations"
        required: false
      DIRECT_URL:
        description: "Direct database URL for Prisma migrations (preferred if available)"
        required: false
      # Render
      RENDER_DEPLOY_HOOK_URL_STAGING:
        description: "Render deploy hook URL for the staging service"
        required: false
      RENDER_DEPLOY_HOOK_URL_PRODUCTION:
        description: "Render deploy hook URL for the production service"
        required: false
      # AWS ECS
      AWS_ACCESS_KEY_ID:
        description: "AWS access key for ECS deployments (consider using OIDC instead of long-lived keys)"
        required: false
      AWS_SECRET_ACCESS_KEY:
        description: "AWS secret key for ECS deployments"
        required: false
      AWS_REGION:
        description: "AWS region for ECS deployments"
        required: false
      ECS_CLUSTER:
        description: "ECS cluster name"
        required: false
      ECS_SERVICE:
        description: "ECS service name"
        required: false
      ECS_TASK_DEFINITION_FAMILY:
        description: "ECS task definition family to update"
        required: false
      # GCP Cloud Run
      GCP_PROJECT_ID:
        description: "GCP project ID for Cloud Run deployments"
        required: false
      GCP_REGION:
        description: "GCP region for Cloud Run deployments"
        required: false
      GCP_CLOUD_RUN_SERVICE:
        description: "Cloud Run service name"
        required: false
      GCP_SA_KEY:
        description: "GCP service account JSON key (if not using workload identity federation)"
        required: false

concurrency:
  group: deploy-${{ inputs.environment }}-${{ inputs.deploy_target }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: read # required for pulling images from GHCR during migrations
  id-token: write # required for GCP OIDC; safe no-op for other providers

env:
  # Default image repository; callers can pass a full image reference via image_tag if needed
  IMAGE_REPOSITORY: ghcr.io/${{ github.repository_owner }}/kitchen-hub-api

jobs:
  migrations:
    name: Run database migrations
    runs-on: ubuntu-latest

    steps:
      - name: Validate migration configuration
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.DIRECT_URL }}" ] && [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "ERROR: Either DIRECT_URL or DATABASE_URL secret must be provided for migrations."
            exit 1
          fi

      - name: Determine image reference
        id: image
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ inputs.image_tag }}"
          # If the caller provided a full image reference (starts with ghcr.io), use it as-is.
          # Otherwise, prepend the default repository.
          # Note: This logic is duplicated in the deploy job due to GitHub Actions job isolation.
          if echo "$IMAGE_TAG" | grep -q '^ghcr.io/'; then
            echo "value=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          else
            echo "value=${IMAGE_REPOSITORY}:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          fi

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Prisma migrations
        env:
          DATABASE_URL: ${{ secrets.DIRECT_URL || secrets.DATABASE_URL }}
        run: |
          set -euo pipefail
          IMAGE_REF="${{ steps.image.outputs.value }}"
          echo "Running migrations using image: $IMAGE_REF"

          if [ -z "$DATABASE_URL" ]; then
            echo "ERROR: DATABASE_URL environment variable is not set."
            exit 1
          fi

          docker run --rm \
            -e DATABASE_URL="$DATABASE_URL" \
            "$IMAGE_REF" \
            npx prisma migrate deploy --schema=src/infrastructure/database/prisma/schema.prisma

  deploy:
    name: Deploy to target platform
    runs-on: ubuntu-latest
    needs: migrations

    steps:
      - name: Validate deploy target
        run: |
          set -euo pipefail
          DEPLOY_TARGET="${{ inputs.deploy_target }}"
          case "$DEPLOY_TARGET" in
            render|aws-ecs|gcp-cloudrun)
              echo "Valid deploy target: $DEPLOY_TARGET"
              ;;
            *)
              echo "ERROR: Invalid deploy_target '$DEPLOY_TARGET'. Must be one of: render, aws-ecs, gcp-cloudrun"
              exit 1
              ;;
          esac

      - name: Validate environment
        run: |
          set -euo pipefail
          ENVIRONMENT="${{ inputs.environment }}"
          if [ "$ENVIRONMENT" != "staging" ] && [ "$ENVIRONMENT" != "production" ]; then
            echo "WARNING: Environment '$ENVIRONMENT' is not 'staging' or 'production'. Some providers may not handle this correctly."
          fi

      - name: Determine image reference
        id: image
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ inputs.image_tag }}"
          # If the caller provided a full image reference (starts with ghcr.io), use it as-is.
          # Otherwise, prepend the default repository.
          if echo "$IMAGE_TAG" | grep -q '^ghcr.io/'; then
            echo "value=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          else
            echo "value=${IMAGE_REPOSITORY}:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          fi

      - name: Log image reference
        run: echo "Deploying image ${{ steps.image.outputs.value }} to ${{ inputs.deploy_target }} in ${{ inputs.environment }} environment"

      # -------- Render --------
      - name: Trigger Render deploy
        if: inputs.deploy_target == 'render'
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          RENDER_DEPLOY_HOOK_URL_STAGING: ${{ secrets.RENDER_DEPLOY_HOOK_URL_STAGING }}
          RENDER_DEPLOY_HOOK_URL_PRODUCTION: ${{ secrets.RENDER_DEPLOY_HOOK_URL_PRODUCTION }}
        run: |
          set -euo pipefail
          # Select the appropriate hook URL based on environment
          if [ "$ENVIRONMENT" = "staging" ]; then
            HOOK_URL="$RENDER_DEPLOY_HOOK_URL_STAGING"
          elif [ "$ENVIRONMENT" = "production" ]; then
            HOOK_URL="$RENDER_DEPLOY_HOOK_URL_PRODUCTION"
          else
            echo "ERROR: Render deploy hook URL is only configured for 'staging' and 'production' environments. Got: $ENVIRONMENT"
            exit 1
          fi

          if [ -z "$HOOK_URL" ]; then
            echo "ERROR: Render deploy hook URL is not configured for environment: $ENVIRONMENT"
            exit 1
          fi

          echo "Triggering Render deploy via hook: $HOOK_URL"
          curl -fsSL -X POST "$HOOK_URL"

      # -------- AWS ECS --------
      - name: Configure AWS credentials
        if: inputs.deploy_target == 'aws-ecs'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to Amazon ECS
        if: inputs.deploy_target == 'aws-ecs'
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
          ECS_TASK_DEFINITION_FAMILY: ${{ secrets.ECS_TASK_DEFINITION_FAMILY }}
        run: |
          set -euo pipefail

          if [ -z "$ECS_CLUSTER" ] || [ -z "$ECS_SERVICE" ] || [ -z "$ECS_TASK_DEFINITION_FAMILY" ]; then
            echo "ERROR: ECS_CLUSTER, ECS_SERVICE, and ECS_TASK_DEFINITION_FAMILY must be set for ECS deployments."
            exit 1
          fi

          # Verify jq is available (should be on ubuntu-latest, but check for clarity)
          if ! command -v jq &> /dev/null; then
            echo "ERROR: jq is required for ECS deployments but is not installed."
            exit 1
          fi

          IMAGE_REF="${{ steps.image.outputs.value }}"
          echo "Updating ECS task definition family '$ECS_TASK_DEFINITION_FAMILY' with image $IMAGE_REF"

          # Create temporary file for task definition
          TASK_DEF_FILE=$(mktemp)
          trap "rm -f $TASK_DEF_FILE" EXIT

          # Fetch the latest task definition and update image
          TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$ECS_TASK_DEFINITION_FAMILY")
          NEW_TASK_DEF=$(echo "$TASK_DEF_JSON" | \
            jq --arg IMAGE "$IMAGE_REF" '.taskDefinition | .containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          echo "$NEW_TASK_DEF" > "$TASK_DEF_FILE"
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "file://$TASK_DEF_FILE" --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "Registered new task definition: $NEW_TASK_DEF_ARN"

          echo "Updating ECS service '$ECS_SERVICE' in cluster '$ECS_CLUSTER' to use new task definition"
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --force-new-deployment

      # -------- GCP Cloud Run --------
      - name: Set up gcloud auth
        if: inputs.deploy_target == 'gcp-cloudrun'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud SDK
        if: inputs.deploy_target == 'gcp-cloudrun'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Deploy to Cloud Run
        if: inputs.deploy_target == 'gcp-cloudrun'
        env:
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_REGION: ${{ secrets.GCP_REGION }}
          GCP_CLOUD_RUN_SERVICE: ${{ secrets.GCP_CLOUD_RUN_SERVICE }}
        run: |
          set -euo pipefail

          if [ -z "$GCP_PROJECT_ID" ] || [ -z "$GCP_REGION" ] || [ -z "$GCP_CLOUD_RUN_SERVICE" ]; then
            echo "ERROR: GCP_PROJECT_ID, GCP_REGION, and GCP_CLOUD_RUN_SERVICE must be set for Cloud Run deployments."
            exit 1
          fi

          IMAGE_REF="${{ steps.image.outputs.value }}"
          echo "Deploying Cloud Run service '$GCP_CLOUD_RUN_SERVICE' in project '$GCP_PROJECT_ID' (region: $GCP_REGION) with image $IMAGE_REF"

          gcloud run deploy "$GCP_CLOUD_RUN_SERVICE" \
            --project="$GCP_PROJECT_ID" \
            --region="$GCP_REGION" \
            --image="$IMAGE_REF" \
            --platform=managed \
            --quiet

  health_check:
    name: Post-deploy health check
    runs-on: ubuntu-latest
    needs: deploy
    # Health checks are optional; run only when a service URL is provided by the caller.
    if: ${{ inputs.service_url != '' }}

    steps:
      - name: Ensure service_url is provided
        run: |
          set -euo pipefail
          if [ -z "${{ inputs.service_url }}" ]; then
            echo "ERROR: service_url input is required for health checks."
            exit 1
          fi

      - name: Wait for service to become healthy
        run: |
          set -euo pipefail

          BASE_URL="${{ inputs.service_url }}"
          HEALTH_URL="${BASE_URL%/}/api/version"
          echo "Checking health endpoint: $HEALTH_URL"

          # Wait for service to start before beginning health checks
          initial_delay_seconds=30
          echo "Waiting ${initial_delay_seconds}s for service to start before health checks..."
          sleep "$initial_delay_seconds"

          max_attempts=6
          attempt=1
          sleep_seconds=20

          while [ "$attempt" -le "$max_attempts" ]; do
            echo "Health check attempt $attempt of $max_attempts..."
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

            if [ "$status_code" = "200" ]; then
              echo "Service is healthy (HTTP 200)."
              exit 0
            fi

            echo "Service not healthy yet (status: $status_code). Waiting ${sleep_seconds}s before retrying..."
            attempt=$((attempt + 1))
            if [ "$attempt" -le "$max_attempts" ]; then
              sleep "$sleep_seconds"
            fi
          done

          echo "ERROR: Service did not become healthy after $max_attempts attempts."
          exit 1

      - name: Summary of deployment
        run: |
          echo "Deployment completed for:"
          echo "  Environment: ${{ inputs.environment }}"
          echo "  Target:      ${{ inputs.deploy_target }}"
          echo "  Image:       ${{ inputs.image_tag }}"
          echo "  Health URL:  ${{ inputs.service_url }}/api/version"

# -----------------------------------------------------------------------------
# Example usage (caller workflows)
#
# Staging (Render):
# jobs:
#   deploy-staging:
#     uses: ./.github/workflows/_deploy.yml
#     with:
#       environment: staging
#       deploy_target: render
#       image_tag: develop-latest
#       service_url: https://staging-api.example.com
#     secrets:
#       DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
#       DIRECT_URL: ${{ secrets.STAGING_DIRECT_URL }}
#       RENDER_DEPLOY_HOOK_URL_STAGING: ${{ secrets.RENDER_DEPLOY_HOOK_URL_STAGING }}
#
# Production (AWS ECS):
# jobs:
#   deploy-production:
#     uses: ./.github/workflows/_deploy.yml
#     with:
#       environment: production
#       deploy_target: aws-ecs
#       image_tag: main-latest
#       service_url: https://api.example.com
#     secrets:
#       DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
#       DIRECT_URL: ${{ secrets.PROD_DIRECT_URL }}
#       AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
#       AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#       AWS_REGION: ${{ secrets.AWS_REGION }}
#       ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
#       ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
#       ECS_TASK_DEFINITION_FAMILY: ${{ secrets.ECS_TASK_DEFINITION_FAMILY }}
#
# Production (GCP Cloud Run):
# jobs:
#   deploy-production-gcp:
#     uses: ./.github/workflows/_deploy.yml
#     with:
#       environment: production
#       deploy_target: gcp-cloudrun
#       image_tag: main-latest
#       service_url: https://api.example.com
#     secrets:
#       DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
#       DIRECT_URL: ${{ secrets.PROD_DIRECT_URL }}
#       GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
#       GCP_REGION: ${{ secrets.GCP_REGION }}
#       GCP_CLOUD_RUN_SERVICE: ${{ secrets.GCP_CLOUD_RUN_SERVICE }}
#       GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}

